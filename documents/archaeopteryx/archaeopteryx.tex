%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% File:   archaeopteryx.tex
% Author: Sudnya Diamos
%         Gregory Diamos
% Date:   Saturday September 3, 2011
% Brief:  The latex source file for the Archaeopteryx simulator paper.
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\documentclass[12pt]{report}
\documentclass[conference, 10pt]{IEEEtran}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Included Packages
\usepackage{cite} 
\usepackage[pdftex]{graphicx} 
\usepackage{url}
\usepackage{booktabs} 
\usepackage{setspace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Configure Document
\topmargin      0.0in
\headheight     0.0in
\headsep        0.0in
\oddsidemargin  0.0in
\evensidemargin 0.0in
\textheight     9.0in
\textwidth      6.5in
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Configure Packages
\graphicspath{{images/}} 
\DeclareGraphicsExtensions{.pdf,.jpeg,.png} 
\pagenumbering{arabic}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% New Commands
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% High Level Organization (See individual sections for details) - 8000 words
% 
% Chapter 1) - Introduction                            - 1000 words
% Chapter 2) - Vanaheimr introduction                  - 500  words
% Chapter 3) - Executive Summary (emphasis on speedup) - 750  words
% Chapter 4) - Framework Design                        - 1750 words
% Chapter 5) - Simulator Core Design                   - 3000 words
% Chapter 6) - Experimental Evaluation                 - 1000 words
% Chapter 7) - Related Work                            - 500  words
% Chapter 8) - Conclusions                             - 500  words
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title and Authors
\title{Archaeopteryx\\
Simulating Future Architectures on GPUs}

\author{Sudnya Diamos and Gregory Diamos  \\
No Affiliation \\
{\small mailsudnya@gmail.com, gregory.diamos@gatech.edu}}
\date{\today}

\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Section 1 - 1000 words
\section{Introduction}
\label{sec:introduction}

% Survey of the space
The transition to many core computing has coincided with the growth of
data parallel computation and the evolution of graphics processing
units (GPUs) from special purpose devices to programmable cores. 
The emergence of low cost programmable GPU computing substrates from
NVIDIA, Intel, AMD, and ARM have made data parallel architectures commodity
from embedded systems through large scale clusters such as the
Tsubame~\cite{ref:tsubame} and Keeneland systems~\cite{ref:keeneland}
hosting thousands of GPU chips.

The dominant programming systems involve the use of
bulk-synchronous-parallel programming models~\cite{ref:bulk-synchronous}
embodied by languages such as CUDA, OpenCL, and C++-AMP.  These data-parallel
languages implement \textit{single instruction stream multiple thread} (SIMT)
models of computation that specify a large number of
data-parallel threads that can be readily exploited by hardware
multi-threading and \textit{single-instruction-multiple-data} (SIMD)
cores. 

In contrast to many-core processors based on out-of-order CPU cores,
GPU architectures are designed to exploit the massive data-parallelism of
bulk-synchronous programs. Performance is maximized for regular computations
where hardware can use SIMD pipelines and bulk data transfers to exploit
control and data locality among threads.  However, current designs suffer
from steep performance cliffs when executing programs with irregular control
flow and data access patterns.  
%They are also 
%from branch divergence (when threads take
%different paths through the program) and memory divergence (when threads perform
%scatter or gather memory accesses).  
They are also beginning to introduce new
programming hazards as they move to \textit{non-uniform memory access} (NUMA)
organizations to reduce on-chip network overheads.  

These performance hazards complicate GPU programming. In fact, sequential
algorithms mapped to single CPU cores are still competitive with GPUs for many
application domains (e.g. database queries, loss-less compression,
lexing/parsing, or graph analytics) despite a 300x (and exponentially growing)
difference in peak throughput.  Two of the most important problems in computing
today involve designing architectures with more gradual performance cliffs
(without sacrificing parallel efficiency), and
designing bulk-synchronous algorithms for irregular applications.  

% attention grabber
Unfortunately, the tools that have been traditionally used to explore solutions
to these problems (architecture simulators and analytical models) fall into the
category of applications \textit{without} efficient parallel implementations. 
This has created a gap between parallel processor and simulator performance that
is widening with each successive generation, limiting the ability of architects
to explore the design space of possible optimizations and the ability of
application designers to evaluate the impact of algorithms on future
architectures.  

% Functional modeling
This is even more troubling for functional verification.  Although most bugs are
still caught with relatively short directed tests~\cite{ref:bug-distributions},
a critical class of bugs only occurs during complex interactions between
multiple components.  These bugs are typically discovered through application
stress testing or random program execution.   As application complexity
continues to grow with processor capability, there is a rising concern that
simulator performance will limit application and random test coverage,
especially for applications with multiple phases.  

% Why are we doing this?
It would be desirable to leverage the tremendous growth in computing potential
provided by parallel processors for microarchitecture simulation.  However,
the sequential operation and tight dependency loops in high performance 
processor pipelines quickly dash the hopes of straightforward solutions.
Exploiting fine-grained data parallelism and expressing the operation of a
processor in terms of hierarchical bulk data transfers requires a ground-up
approach.

% Our approach
In this paper, we assert that the parallel and hierarchical organization of
microarchitecture structures used in modern processors provide a natural
basis for simulation using data-parallel algorithms.  We test this assertion by
implementing a composable functional simulator for a new processor architecture,
and then augment it with performance models for key micro-architecture
structures.  We exploit fine-grained data parallelism by using hundreds of
threads to simulate a single core.  We show how basic parallel algorithm
building blocks like reductions, prefix sums, sorts, and histograms can be used
to simulate instruction fetch units, register files, thread schedulers,
functional units, and caches.  Across X applications, we show that the accuracy
of the simulation is comparable to state-of-the-art sequential simulators, and
that the performance of the simulator scales across three generations of GPUs.
This paper describes the first data-parallel processor simulator that can 
leverage the technology scaling and microarchitecture enhancements of the
previous generation of GPU hardware to simulate the next.

% Contributions
Specifically, this paper makes the following contributions:

\begin{itemize}
	\item It describes the design of the first processor simulator implemented
		completely in the CUDA "C" language.

	\item It introduces a design methodology for simulating parallel processors
		that achieves near peak utilization of modern GPU accelerators and
		good scaling across three generations of GPUs.
		
	\item It shows that microarchitecture details, such as scratchpad sizes,
		hardware thread schedulers, register file organizations, cache
		hierarchies, and core pipelines can be simulated quickly as long as
		the hierarchical organization of the machine is maintained.
	
	\item It compares the results and performance of our parallel simulator with
		two existing GPU simulators: GPGPU-Sim, and the Ocelot PTX Emulator.  
		We demonstrate a Nx speedup.
\end{itemize}

\subsection{Outline}

This document is organized as follows.  The first section walks through the
execution of sample application on the proposed simulator.  The second section
provides a high level overview of the simulator framework.  The third section
drills down into the implementation details of the simulator.  This is followed
by an evaluation of the speed and accuracy of the simulator.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Section 2 - 500 words
\section{Vanaheimr}
\label{sec:vanaheimr}

Vanaheimr is an architecture that is optimized to execute Multi-BSP programs
that express a high degree of parallelism hierarchically.  The memory system
is composed of memory controllers that are tiled across the processor die
and connected to 3D DRAM modules either directly through vias, or
indirectly through a silicon interposer.  The cache is organized
into an H-tree structure, with clusters at each level of the hierarchy.  Each
level is connected by a stage of an indirect network.  The cache bank size,
number of levels, as well as degree of connectivity at each level is
configurable.  The cores themselves implement a hierarchical SIMD architecture.
The main difference between this and a traditional SIMD processor is that the
unit of control that is broadcast to multiple execution units is larger than
a single instruction; it is referred to as a sub-kernel.  The architecture
is intended to scale across regular and irregular applications by varying the
ratio of execution units to memory, and the number of levels in the
interconnection network.  

\subsection{Architecture}
This paper is concerned with the design of a functional simulator for the
Vanaheimr architecture, so only the essential aspects are mentioned here. 
Additional details about the architecture are described in related
work~\cite{ref:vanaheimr}.  

Vanaheimr targets 100 TFLOPs peak throughput at a 5nm technology node on a
300mm$^2$ die, while peak single-threaded CPU performance is currently limited
to less than 15 GFLOPs~\cite{ref:sandybridge-peak}.  In order to bridge the gap
between simulator and hardware performance, the Archqopteryx simulator is
implemented using Multi-BSP algorithms intended to execute on a commodity
parallel processor, such as NVIDIA Kepler with a peak throughput of 2.5 TFLOPs
or greater.

Although some components, namely the SIMD lanes, used in the Vanaheimr
architecture map naturally onto the CUDA model, the memory system, network,
and core control logic exhibit either serial operation in hardware or many
fine-grained dependences.  These components are modeled individually leveraging
bulk-parallelism where it exists (such as among network buffers and lanes),
falling back to serial execution where it does not (such as the SIMD instruction
fetch to broadcast loop), and composed together hierarchically into groups
that expand or contract the amount of parallelism in the simulation.  

\subsection{Programming Model}
Vanaheimr programs are compiled into an intermediate form, VIR (the Vahanheimr
Internal Representation), from a high level language such as CUDA with nested
parallelism, OpenCL, Phalanx, Sequoia, or any other that can be mapped onto
the Multi-BSP model.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Section 2 - 750 words
\section{Executive Summary}
\label{sec:summary}

This paper begins with a concrete example of the simulation of single
application on an instance of the Vanaheimr processor architecture.  

\subsection{Compilation}

\subsection{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Section 3 - 1750 words
\section{Framework Design}
\label{sec:framework-design}

\subsection{Execution Model}

\subsection{Host Reflection}

\paragraph{File IO}

\paragraph{Program Representation}

Intrinsic functions are lowered as late as possible, below the
VIR level, allowing a backend compiler to map them directly onto hardware
acceleration if available.  For simplicity, the Archaeopteryx core model
executes one machine instruction for each virtual instruction as a baseline.

%
% Vanaheimr high level figure
% Vanaheimr core figure
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Section 4 - 3000 words
\section{Simulator Core Design}
\label{sec:core-design}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Section 5 1000 words
\section{Experimental Evaluation}
\label{sec:experiments}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Section 6 - 500 words
\section{Related Work}
\label{related-work}

% PTL-Sim

% RAMP

% GPGPU-SIM, Barra, GPU-Ocelot
\cite{ref:ocelot-pact}

% Parallel simulation, PDES, multi-threaded, CUDA simulation of many-core

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Section 7 - 500 words
\section{Conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bibliography
\bibliographystyle{IEEEtran}
\bibliography{archaeopteryx}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

